# 第29组_软件报告

------

小组成员：

吴承泽	PB19051183

刘伟		PB19051195

梁峻滔	PB19051175

------

## 一、需求分析

### 1、项目背景

​		静态网页的需求是普遍的，但是静态网页的编写需要使用 HTML 语言，而直接编写 HTML 语言有一定麻烦。Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，其语法精简易学。因此，如果可以将 Markdown 文档转换成有效的 HTML 文档，将极大方便人们编辑静态网页。本项目旨在实现一个基本功能为将 Markdown 文档转换成 HTML 文档的软件。

### 2、需求分析

####  2.1 目标功能描述

拟实现的软件可以具有以下功能：

1. GFM 规范中的 文本、标题、目录、图片、链接 五项基本内容；
2. GFM 规范中的其他标记：加粗、斜体、下划线、代码、删除线、引用、代码块 ；
3. 实现HTML中的目录索引功能。

#### 2.2 功能需求分析

1. GFM 规范中的`Text`、`Headers`、`Lists`、`Images`、`Links`分别对应文本、标题、列表、图片和链接，基本所有网页有含有这些内容，必然需要实现。
2. 增加实现 GFM 规范中的`Emphasisi`、`Blockquotes`，可以丰富文本的表现方式，也是人们在文档中普遍使用的；实现`Code Blocks`则是为程序员在网页中展示代码提供方便。
3. 增加实现了HTML中的目录索引，点击即可直接跳转至标题位置，有效提高了html中查找的效率。

### 3、运行需求

运行本软件所需要的环境：Linux下编译运行。

## 二、概要设计

### 1、解析过程

​		在分析markdown文件时，主要采用逐行解析的逻辑，对文本的每一行都进行分析并构建语法树，根据当前行的语法将创建的结点插入到语法树中，最终得到包含markdown文件全部内容的语法树。最后，通过展开语法树，将解析之后的文档用html的形式展示。

### 2、类的定义

​		以下类的定义为针对实现对markdown文本的语法解析和到html文本的转换而设定、以下是类的定义部分。

```c++
class Deriver
{
private:
	//文本内容结点
    Cnode *Croot, *current; 
	//索引内容结点
    Tnode *Troot;	
	//用于存放文本内容、索引内容的字符串
    string content, TOC;
    //计数型整型使目录能够正确地索引到HTML中对应内容的位置
    int cntTag;
    //缓存要处理的行
    char line[MAX_LINE_LEN];

    //判断是否为标题
    inline bool isHeading(Cnode *v);
    //判断是否为图片
    inline bool isImage(Cnode *v);
    //判断是否为超链接
    inline bool isHref(Cnode *v);
    
    template <typename T>
    //销毁语法树
    void destroy(T *v);
    //目录节点深度遍历得到html流
    void Tdfs(Tnode *v, string index);
    //文本节点深度遍历得到html流
    int Cdfs(Cnode *v);
    //判断是否为分割线
    inline bool isCutline(char *src);
    //获得段落标识
    inline void makePara(Cnode *v);
    //获得行首'\t'与' '的数量与文本第一个字符的位置
    inline pair<int, char *> tabcount(char *src);
    //获得该行的类型
    inline pair<int, char *> LineType(char *src);
    //查找对应插入结点的位置
    inline Cnode *findnode(int depth);
    //目录节点内容插入
    void Tinsert(Tnode *v, int x, const string &headstr, int tag);
    //文本结点内容插入
    void Cinsert(Cnode *v, const string &src);

public:
    //构造函数
    Deriver(const std::string &filename);
    //获取markdown目录
    string getTable();
    //获取markdown内容
    string getContent();
    //析构函数
    ~Deriver();
};
```

​	

### 3、结点定义

​		结点类型分为目录节点与文本结点，目录节点存放了目录的内容以及标签，文本结点存放了正文的内容。

```C++ 
//存放目录的结构, 一个结点即一个目录项
typedef struct Tnode

//存放正文的结构, 一个结点即一个正文项
typedef struct Cnode
```

### 4、主程序流程

```c++
int main()
{
    //装载目标Markdown文件
    Deriver transformer("test.md"); 
	//获取目标md文件的HTML格式的目录
    std::string table = transformer.getTable(); 
	//获取目标md文件转换成HTML格式后的内容
    std::string contents = transformer.getContent(); 

    //准备要写入的HTML文件的头尾信息
    std::string head = "<!DOCTYPE html><html><head>\
        <meta charset=\"utf-8\">\
        <title>Markdown</title>\
        <link rel=\"stylesheet\" href=\"github-markdown.css\">\
        </head><body><article class=\"markdown-body\">";
    std::string end = "</article></body></html>";

    //将结果写入到文件
    std::ofstream out;
    //html文件会被放入一个预先生成的Output文件夹中
    out.open("output/test.html");
    //将转换后的内容加到HTML头、尾内部
    out << head + table + contents + end; 
    
    out.close();
    return 0;
}
```

### 5、模块调用关系

`getTable`与`getContent`是主要的转换函数，对要转换的markdown文件进行语法分析，期间需要调`tabcount()`、`makePara()`、`LineType()`、`isCutline()`、`Cinsert()`、`Tinsert()`成员函数来构造语法树，之后需要调用`Cdfs()`与`Tdfs`来展开语法树生成正文部分的html源代码，之后生成的table与contents加上预先设定好的head和end部分后导出一份完整的目标html文件。

## 三、详细设计

### 1、结点结构体设计

```C++ 
//存放目录的结构, 一个结点即一个目录项, 以下为一个目录项所含内容
typedef struct Tnode
{
    vector<Tnode *> vec;						//结点子嗣
    string head; 								//标题内容
    string tag;									//标题标签
    Tnode(const string &headstr) : head(headstr) {} //目录结点的构造函数
} Tnode;

//存放正文的结构, 一个结点即一个正文项, 以下为一个目录项所含内容
typedef struct Cnode
{
    int type; 						  //结点代表的md词法类型
    vector<Cnode *> vec;			  //结点子嗣
    string elem[3];                   //存放三个重要属性, elem[0]存放要显示的内容
                                      //elem[1]存放链接, elem[2]存放title
    Cnode(int _type) : type(_type) {} //目录结点的构造函数
} Cnode;                              //语法树的结点, 一个结点存放一行的信息
```

### 2、类函数设计

#### 2.1 Deriver

​		构造函数的主要思想即，以流的方式一行一行的读取md文件的内容。对应每行会在Croot下生成对应结点，并将文本存储在对应底层的结点中，构造语法树。读取完md内容后，深度遍历语法树，以深度遍历的顺序转化输出html文件。

```C++
    Deriver::Deriver(const std::string &filename)
    {
        Troot = new Tnode("");
        Croot = new Cnode(nul);
        current = Croot;

        std::ifstream fin(filename);

        bool newpara = false;
        bool inblock = false;
        while (!fin.eof())
        {
            //从文件中获取一行
            fin.getline(line, MAX_LINE_LEN);
            //printf("start %s end\n", line);

            //处理不在代码块中且该行是分割线的情况
            if (!inblock && isCutline(line))
            {
                current = Croot;
                current->vec.push_back(new Cnode(hr));
                newpara = false;
                continue;
            }

            //计算一行中开始的空格和tab数
            std::pair<int, char *> ps = tabcount(line);

            //如果不是位于代码块中, 且ps.second为nulptr, 则直接读取下一行
            if (!inblock && ps.second == nullptr)
            {
                current = Croot;
                newpara = true;
                continue;
            }

            //分析该行文本的类型
            std::pair<int, char *> tp = LineType(ps.second);
            //printf("PSTART %s END\n", ps.second);

            //是代码块类型
            if (tp.first == blockcode)
            {
                //如果位于代码块中, 则push一个空类型的结点
                inblock ? current->vec.push_back(new Cnode(nul)) : current->vec.push_back(new Cnode(blockcode));
                inblock = !inblock;
                continue;
            }

            //如果位于代码块中, 直接将内容拼接到当前结点中
            if (inblock)
            {
                current->vec.back()->elem[0] += string(line) + '\n';
                continue;
            }

            //是普通段落
            //FIXME:删除线、粗体混用出错的地方
            if (tp.first == paragraph)
            {
                if (current == Croot)
                {
                    current = findnode(ps.first);
                    current->vec.push_back(new Cnode(paragraph));
                    current = current->vec.back();
                }
                bool flag = false;
                if (newpara && !current->vec.empty())
                {
                    Cnode *ptr = nullptr;
                    for (auto i : current->vec)
                    {
                        if (i->type == nul)
                            ptr = i;
                    }
                    if (ptr != nullptr)
                        makePara(ptr);
                    flag = true;
                }
                if (flag)
                {
                    current->vec.push_back(new Cnode(paragraph));
                    current = current->vec.back();
                }
                current->vec.push_back(new Cnode(nul));
                Cinsert(current->vec.back(), string(tp.second));
                //printf("duanluo%s \n", tp.second);
                newpara = false;
                continue;
            }

            current = findnode(ps.first);

            //如果是标题行, 则向其标签中插入属性tag
            if (tp.first >= h1 && tp.first <= h6)
            {
                current->vec.push_back(new Cnode(tp.first));
                current->vec.back()->elem[0] = "tag" + to_string(++cntTag);
                Cinsert(current->vec.back(), string(tp.second));
                Tinsert(Troot, tp.first - h1 + 1, string(tp.second), cntTag);
            }

            //如果是无序列表
            if (tp.first == ul)
            {
                if (current->vec.empty() || current->vec.back()->type != ul)
                {
                    current->vec.push_back(new Cnode(ul));
                }
                current = current->vec.back();
                current->vec.push_back(new Cnode(li));
                current = current->vec.back();
                Cinsert(current, string(tp.second));
            }
            //如果是有序列表
            if (tp.first == ol)
            {
                if (current->vec.empty() || current->vec.back()->type != ol)
                {
                    current->vec.push_back(new Cnode(ol));
                }
                current = current->vec.back();
                current->vec.push_back(new Cnode(li));
                current = current->vec.back();
                Cinsert(current, string(tp.second));
            }

            //如果是引用
            if (tp.first == quote)
            {
                if (current->vec.empty() || current->vec.back()->type != quote)
                {
                    current->vec.push_back(new Cnode(quote));
                }
                current = current->vec.back();
                if (newpara || current->vec.empty())
                    current->vec.push_back(new Cnode(paragraph));
                Cinsert(current->vec.back(), string(tp.second));
            }

            newpara = false;
        }

        //文件读取分析完毕
        fin.close();

        //深度优先遍历整棵语法树
        Cdfs(Croot);

        //构造目录
        TOC += "<ul>";
        for (int i = 0; i < (int)Troot->vec.size(); i++)
            Tdfs(Troot->vec[i], to_string(i + 1) + ".");
        TOC += "</ul>";
    }
```

#### 2.2 Cinsert

​		文本插入函数的主要思想即对每一行的每一个字符进行判断，通过设置有限的状态表征文本的类型，并转化成对应的结点同时存储在v结点的vec下，同时将文本存储在对应结点下。

```c++
    void Deriver::Cinsert(Cnode *v, const string &src)
    {
        int srclen = src.size();
        bool incode = false,    //标志是否是行内代码
            inem = false,       //标志是否是行内斜体
            instrong = false,   //标志是否是行内加粗
            inautolink = false, //标志是否是行内链接
            indel = false,      //标志是否是删除线
            inunderline = false;//标志是否是下划线
        v->vec.push_back(new Cnode(nul));

        for (int i = 0; i < srclen; i++) //检查src字符串中的每一个字符
        {
            char ch = src[i];
            if (ch == '\\') //反斜杠的下一个字符即为转义字符
            {
                ch = src[++i];
                v->vec.back()->elem[0] += string(1, ch);
                continue;
            }

            //处理行内代码
            if (ch == '`' && !inautolink) //要求不是行内链接
            {
                if (incode)
                    v->vec.push_back(new Cnode(nul)); //如果incode为真，则当前ch是第二个'`'，增加一个空类型的结点
                else
                    v->vec.push_back(new Cnode(code)); //incode为假，当前ch是首个'`'，增加一个code类型的结点
                incode = !incode;
                continue;
            }

            //处理加粗，注意"***混合***”的情况
            if (ch == '*' && (i < srclen - 1 && (src[i + 1] == '*')) && !incode && !inautolink)
            { //读取到连续两个'*'，可能是加粗
                ++i;
                if (instrong)
                    v->vec.push_back(new Cnode(nul));
                else
                    v->vec.push_back(new Cnode(strong)); //如果instrong为假，则当前读到的连续两个'*'是首次，增加一个strong类型结点
                instrong = !instrong;
                continue;
            }
            if (ch == '_' && (i < srclen - 1 && (src[i + 1] == '_')) && !incode && !inautolink)
            { //读取到连续两个'_'，可能是加粗
                ++i;
                if (instrong)
                    v->vec.push_back(new Cnode(nul));
                else
                    v->vec.push_back(new Cnode(strong)); //如果instrong为假，则当前读到的连续两个'*'是首次，增加一个strong类型结点
                instrong = !instrong;
                continue;
            }

            //处理斜体
            //FIXME:
            //if (ch == '_' && !incode && !instrong && !inautolink)
            if (ch == '_' && src[i + 1] != '_' && !incode && !inautolink)
            { //只有单独的一个'_'，可能是斜体
                if (inem)
                    v->vec.push_back(new Cnode(nul));
                else
                    v->vec.push_back(new Cnode(em));
                inem = !inem;
                continue;
            }
            if (ch == '*' && src[i + 1] != '*' && !incode && !inautolink)
            { //只有单独的一个'*'，可能是斜体
                if (inem)
                    v->vec.push_back(new Cnode(nul));
                else
                    v->vec.push_back(new Cnode(em));
                inem = !inem;
                continue;
            }

            //处理删除线
            if (ch == '~' && (i < srclen - 1 && (src[i + 1] == '~')) && !incode && !inautolink)
            {
                ++i;
                //indel ? v->vec.push_back(new Cnode(nul)) : v->vec.push_back(new Cnode(del));
                if (indel)
                    v->vec.push_back(new Cnode(nul));
                else
                    v->vec.push_back(new Cnode(del));
                indel = !indel;
                continue;
            }

            //TODO:处理下划线
            if (ch == '<' && src[i + 1] == 'u' && src[i + 2] == '>' && !incode && !inautolink)
            {
                i = i + 2;
                if (inunderline)
                    v->vec.push_back(new Cnode(nul));
                else
                    v->vec.push_back(new Cnode(underline));
                inunderline = !inunderline;
                continue;
            }

            //处理图片
            if (ch == '!' && (i < srclen - 1 && src[i + 1] == '[') && !incode && !instrong && !inem && !inautolink)
            {
                v->vec.push_back(new Cnode(image));
                for (i += 2; i < srclen - 1 && src[i] != ']'; i++)
                    v->vec.back()->elem[0] += string(1, src[i]);
                i++;
                for (i++; i < srclen - 1 && src[i] != ' ' && src[i] != ')'; i++)
                    v->vec.back()->elem[1] += string(1, src[i]);
                if (src[i] != ')')
                    for (i++; i < srclen - 1 && src[i] != ')'; i++)
                        if (src[i] != '"')
                            v->vec.back()->elem[2] += string(1, src[i]);
                v->vec.push_back(new Cnode(nul));
                continue;
            }

            //处理超链接
            if (ch == '[' && !incode && !instrong && !inem && !inautolink)
            {
                v->vec.push_back(new Cnode(href));
                for (i++; i < srclen - 1 && src[i] != ']'; i++)
                    v->vec.back()->elem[0] += string(1, src[i]);
                i++;
                for (i++; i < srclen - 1 && src[i] != ' ' && src[i] != ')'; i++)
                    v->vec.back()->elem[1] += string(1, src[i]);
                if (src[i] != ')')
                    for (i++; i < srclen - 1 && src[i] != ')'; i++)
                        if (src[i] != '"')
                            v->vec.back()->elem[2] += string(1, src[i]);
                v->vec.push_back(new Cnode(nul));
                continue;
            }

            //ch读到的是普通文本
            v->vec.back()->elem[0] += string(1, ch);
            if (inautolink)
                v->vec.back()->elem[1] += string(1, ch);
        }
        if (src.size() >= 2)
            if (src.at(src.size() - 1) == ' ' && src.at(src.size() - 2) == ' ') //字符串最后连续两个空格
                v->vec.push_back(new Cnode(br));
    }
```

#### 2.3 Tinsert

​	目录结点插入函数的主要思想与Cinsert大致相同，对TNode语法树进行深度遍历，在语法树深度为x的向量尾部增加结点，并设置tag标签，负责记录跳转的正文结点。

```c++
     /*新增结点的插入
     *结点的插入分两种类型
     *一种是向Tnode结构的树中插入目录结点
     *设置tag标签来标记一个目录结点所指向的正文结点, 
     *以实现点击目录项即可正确跳转到正文对应的位置
     */
	void Deriver::Tinsert(Tnode *v, int x, const string &headstr, int tag)
    {
        int n = v->vec.size(); //当前结点的vector项数
        if (x == 1)
        {
            v->vec.push_back(new Tnode(headstr)); //向量尾部增加一个结点
            v->vec.back()->tag = "tag" + to_string(tag);
            return;
        }
        if (!n || v->vec.back()->head.empty())
            v->vec.push_back(new Tnode(""));
        Tinsert(v->vec.back(), x - 1, headstr, tag);
    }
```

#### 2.4 findnode

​		寻找插入结点函数的主要思想为，通过深度查找语法树对应深度的最后一个结点，返回值为该结点。

```C++
    Cnode * Deriver::findnode(int depth)
    {
        Cnode *ptr = Croot;
        while (!ptr->vec.empty() && depth != 0)
        {
            ptr = ptr->vec.back(); //返回尾元素的引用
            if (ptr->type == li)
                depth--;
        }
        return ptr;
    }
```

#### 2.5 LineType

​		判断行类型函数主要思想为，对不含首空格文本的前几个字符进行判断，返回标题的类型和指向文本内容首字符的指针。

```c++
     /*判断当前行的类型
     *src: 所要判断的行
     *返回: 当前行的类型和除去行标志性关键字的正式内容的char*组成的pair类型
     */
	pair<int, char *> Deriver::LineType(char *src)
    {
        char *ptr = src;

        //跳过`#`
        while (*ptr == '#')
            ptr++;
        //如果'#'紧跟空格, 则该行是标题
        if (ptr - src > 0 && *ptr == ' ')
            return make_pair(ptr - src + h1 - 1, ptr + 1); //返回标题级数

        //不是标题则从头分析
        ptr = src;

        //FIXME:需要判断是第一次还是第二次出现
        //如果出现```则说明是代码块
        if (strncmp(ptr, "```", 3) == 0)
            return make_pair(blockcode, ptr + 3);

        //FIXME:如果出现* + -, 并且它们的下一个字符为空格, 则该行是无序列表的一项
        if (strncmp(ptr, "- ", 2) == 0 || strncmp(ptr, "+ ", 2) == 0 || strncmp(ptr, "* ", 2) == 0)
            return make_pair(ul, ptr + 1);

        //如果出现 > 且下一个字符为空格, 则该行是引用
        if (strncmp(ptr, "> ", 2) == 0)
            return make_pair(quote, ptr + 1);

        //如果出现的是"数字. ", 则该行是有序列表的一项
        //FIXME:return是加1还是加2?
        char *ptr1 = ptr;
        while (*ptr1 && (isdigit(*ptr1)))
            ptr1++;
        if (ptr1 != ptr && strncmp(ptr1, ". ", 2) == 0)
            return make_pair(ol, ptr1 + 1);

        //否则就是普通段落
        return make_pair(paragraph, ptr);
    }
```

#### 2.5 tabcount

​		tabcount函数主要是记录该行中首字符有多少个' '，并返回其个数与指向第一个不是' '的指针。

```c++
    /*行首的空格和tab不影响对markdown词法的解析
     *所以要先处理行首的空格和tab
     *src：要处理的一行字符串
     *返回: 由空格数和正文开始处的char*指针组成的pair类型
     */    
	pair<int, char *> Deriver::tabcount(char *src)
    {
        //该行是空行
        if (strlen(src) == 0)
            return make_pair(0, nullptr);

        //从该行的第一个字符开始, 统计空格数和tab数, 遇到非空格且非tab时停止
        int spacecnt = 0, tabcnt = 0;
        for (int i = 0; src[i] != '\0'; i++)
        {
            if (src[i] == ' ')
                spacecnt++;
            else if (src[i] == '\t')
                tabcnt++;
            //如果内容前有空格和tab, 则统一按tab的个数处理, 一个tab = 4个空格
            else return make_pair(tabcnt + spacecnt / 4, src + i);
        }
        return make_pair(0, nullptr);
    }
```

#### 2.5 makePara

​		makePara的主要思想为，如果对应文本中为一个新段落（即两行之间有两个'\n')，则生成一个新的paragraph类的Cnode。

```C++

	void Deriver::makePara(Cnode *v)
    {
        if (v->vec.size() == 1u && v->vec.back()->type == paragraph)
            return;
        if (v->type == paragraph)
            return;
        if (v->type == nul)
        {
            v->type = paragraph;
            return;
        }
        Cnode *x = new Cnode(paragraph);
        x->vec = v->vec;
        v->vec.clear();
        v->vec.push_back(x);
    }
```

#### 2.6 isCutline

​		isCutline函数主要是判断该行是否为分割线，若为分割线，则跳过该行，进入下一行。

```c++ 
    bool Deriver::isCutline(char *src)
    {
        int cnt = 0;
        char *ptr = src;
        //如果行首不是空格、tab、-或*, 则这一行不是分割线
        if (*ptr != ' ' && *ptr != '\t' && *ptr != '-' && *ptr != '*')
            return false;
        //模式一: 全部由'-'和空格/tab组成分割线
        while (*ptr)
        {
            if (*ptr != ' ' && *ptr != '\t' && *ptr != '-')
                break;
            if (*ptr == '-')
                cnt++;
            ptr++;
        }
        if (*ptr != '\n') //如果"___"后面跟了文本，这一行就不是分割线了
            return false;
        //模式二: 全部由'-'和空格/tab组成分割线
        if (cnt < 3)
        {
            cnt = 0;
            ptr = src;
            while (*ptr)
            {
                if (*ptr != ' ' && *ptr != '\t' && *ptr != '*')
                    break;
                if (*ptr == '*')
                    cnt++;
                ptr++;
            }
            if (*ptr != '\n') //如果"***"后面跟了文本，这一行就不是分割线了
                return false;
        }
        //如果出现三个以上的'-'或'*', 则需要增加一个分割线, 这时需要换行
        return (cnt >= 3);
    }
```

#### 2.7 Cdfs

​		Cdfs函数的主要思想为，对Cnode函数深度遍历，并将储存的文本以html编码对应的格式储存在content中。

```C++
    int Deriver::Cdfs(Cnode *v)
    {
        if (v->type == paragraph && v->elem[0].empty() && v->vec.empty())
            return 0;

        content += frontTag[v->type];
        bool flag = true;

        //处理标题, 支持用目录进行跳转
        if (isHeading(v))
        {
            content += "id=\"" + v->elem[0] + "\">";
            flag = false;
        }

        //处理超链接
        if (isHref(v))
        {
            content += "<a href=\"" + v->elem[1] + "\" title=\"" + v->elem[2] + "\">" + v->elem[0] + "</a>";
            flag = false;
        }

        //处理图片
        if (isImage(v))
        {
            content += "<img alt=\"" + v->elem[0] + "\" src=\"" + v->elem[1] + "\" title=\"" + v->elem[2] + "\" />";
            flag = false;
        }

        //如果上面三者都不是, 则直接添加内容
        //FIXME:
        if (flag && v->type != 0)
        {
            content += v->elem[0];
            flag = false;
        }

        //递归遍历所有结点
        int vec_amount = (int)v->vec.size();
        int *ret = (int *)malloc(sizeof(int) * vec_amount);
        int record = 0;
        for (int i = 0; i < vec_amount; i++)
        {
            ret[i] = Cdfs(v->vec[i]);
            //TODO:输出该行前半部分的后置标签
            if (ret[i] == -1)
            {
                for (int j = i - 1; j >= 0; j--)
                    if (ret[j] > 0 && v->vec[j]->elem->size() == 0)
                        content += backTag[ret[j]];
                record = i + 1;
                content += v->vec[i]->elem[0];
            }
        }
        //拼接为结束标签
        //FIXME:
        if (!v->elem[0].empty())
        {
            content += backTag[v->type];
            //TODO:考虑“~~**混合1**~~、***混合2***”的情况
            if (v->type == 0) //如果该结点是nul型但elem[0]非空，说明结点后跟的是混合2的情况了，需要告知当前层要把前面的后置标签先输出
                return -1;
        }
        if (v->vec.size())
        {
            for (int i = vec_amount - 1; i >= record; i--)
                if (ret[i] > 0 && v->vec[i]->elem[0].size() == 0)
                    continue;
                    //content += backTag[ret[i]];
            content += backTag[v->type];
        }

        return v->type;
    }
```

#### 2.8 Tdfs

​		Tdfs函数的主要思想为，通过深度遍历Tnode语法树，将标题内容与语法前后缀组合生成索引目录。

```c++ 
    void Deriver::Tdfs(Tnode *v, string index)
    {
        TOC += "<li>\n";
        TOC += "<a href=\"#" + v->tag + "\">" + index + " " + v->head + "</a>\n";
        int n = (int)v->vec.size();
        if (n)
        {
            TOC += "<ul>\n";
            for (int i = 0; i < n; i++)
            {
                Tdfs(v->vec[i], index + to_string(i + 1) + ".");
            }
            TOC += "</ul>\n";
        }
        TOC += "</li>\n";
    }
```

#### 2.9 Destroy

​		深度遍历销毁函数，对每一个结点进行销毁，若有子节点，则优先销毁所有子节点。

```c++
    void Deriver::destroy(T *v)
    {
        for (int i = 0; i < (int)v->vec.size(); i++)
        {
            destroy(v->vec[i]);
        }
        delete v;
    }
```

#### 2.10 其他内联类型返回函数

```c++ 
   //判断是否为标题
    inline bool isHeading(Cnode *v)
    {
        return (v->type >= h1 && v->type <= h6);
    }
    //判断是否为图片
    inline bool isImage(Cnode *v)
    {
        return (v->type == image);
    }
    //判断是否为超链接
    inline bool isHref(Cnode *v)
    {
        return (v->type == href);
    }
```



#### 2.11 public中的对外接口

```C++
    //构造函数
    Deriver(const std::string &filename);

    //获取markdown目录
    string getTable() { return TOC; }
    //获取markdown内容
    string getContent() { return content; }

    //析构函数
    ~Deriver()
    {
        destroy<Cnode>(Croot);
        destroy<Tnode>(Troot);
    }
```



## 四、用户使用说明

### 1、使用说明

#### 1 运行环境

​		代码在包含g++编译资源的Linux系统下，在Terminal中输入

`g++ main.cpp -std=c++11`，编译main.cpp文件成功后输入`./a.out`，在output文件夹中生成了html的生成文件。

![img](file:///C:\Users\86189\AppData\Roaming\Tencent\Users\614752076\QQ\WinTemp\RichOle\@J9[[8BCY{RN9~}GQJYJ5K2.png)

#### 2 文件内容

​		注意，程序文件夹中必须包含main.cpp源文件、class.h头文件、test.md Markdown源文件、及output文件夹用于存放输出的html文件。

![img](file:///C:\Users\86189\AppData\Roaming\Tencent\Users\614752076\QQ\WinTemp\RichOle\8P{B9${(6)B9[4$QY~3~DPB.png)

​		Ubuntu下编译后应有如下文件方可正常运行。

#### 3 输出结果

​		在键入./a.out文件后，可以通过手动打开output文件夹并点击html文件打开。也可以在命令行中输入`cd output`与` firefox test.html`即可通过Firefox浏览器打开html文件。

![img](file:///C:\Users\86189\AppData\Roaming\Tencent\Users\614752076\QQ\WinTemp\RichOle\V57[ZO1DSUN~TEKM1Z@[I7P.png)

## 五、C++源码说明

### 1、源文件(main.cpp)

```c++
#include <fstream>
#include "class.h"

int main()
{
    Deriver transformer("test_text2.md"); //装载目标Markdown文件

    std::string table = transformer.getTable(); //获取目标md文件的HTML格式的目录

    std::string contents = transformer.getContent(); //获取目标md文件转换成HTML格式后的内容

    //准备要写入的HTML文件的头尾信息
    std::string head = "<!DOCTYPE html><html><head>\
        <meta charset=\"utf-8\">\
        <title>Markdown</title>\
        <link rel=\"stylesheet\" href=\"github-markdown.css\">\
        </head><body><article class=\"markdown-body\">";
    std::string end = "</article></body></html>";

    //将结果写入到文件
    std::ofstream out;
    out.open("output/test_text2.html");
    out << head + table + contents + end; //将转换后的内容加到HTML头、尾内部
    out.close();
    return 0;
}

```



### 2、头文件(class.h)

```c++
#ifndef MDtoHTML
#define MDtoHTML

#include <cstdlib>
#include <fstream>
#include <vector>
#include <cstring>
#include <utility>
#include <string>
#include <cctype>
#include <cstdio>
#include <stdlib.h>
#include <iostream>
using namespace std;

#define MAX_LINE_LEN 10000

//markdown语法关键词枚举
//FIXME:增加下划线
enum
{
    nul = 0,            //  开始
    paragraph = 1,      //  段落
    href = 2,           //  超链接
    ul = 3,             //  无序列表
    ol = 4,             //  有序列表
    li = 5,             //  列表
    em = 6,             //  斜体
    strong = 7,         //  加粗
    hr = 8,             //  水平分割线
    br = 9,             //  换行
    image = 10,         //  图片
    quote = 11,         //  引用
    h1 = 12,            //  h1
    h2 = 13,            //  h2
    h3 = 14,            //  h3
    h4 = 15,            //  h4
    h5 = 16,            //  h5
    h6 = 17,            //  h6
    blockcode = 18,     //  代码段
    code = 19,          //  行内代码
    del = 20,           //  删除线
    underline = 21      //  下划线
};
//HTML前置标签
const string frontTag[] = {
    "", "<p>", "", "<ul>", "<ol>", "<li>", "<em>", "<strong>",
    "<hr color=#CCCCCC size=1 />", "<br />",
    "", "<blockquote>",
    "<h1 ", "<h2 ", "<h3 ", "<h4 ", "<h5 ", "<h6 ", //右边的括号预留给添加其他的标签属性
    "<pre><code>", "<code>", "<del>", "<u>"};
//HTML后置标签
const string backTag[] = {
    "", "</p>", "", "</ul>", "</ol>", "</li>", "</em>", "</strong>",
    "", "", "", "</blockquote>",
    "</h1>", "</h2>", "</h3>", "</h4>", "</h5>", "</h6>",
    "</code></pre>", "</code>", "</del>", "</u>"};

//存放目录的结构, 一个结点即一个目录项, 以下为一个目录项所含内容
typedef struct Tnode
{
    vector<Tnode *> vec;
    string head; //标题内容
    string tag;
    Tnode(const string &headstr) : head(headstr) {} //TODO:
} Tnode;

//存放正文的结构
typedef struct Cnode
{
    int type; //结点代表的md词法类型
    vector<Cnode *> vec;
    string elem[3];                   //存放三个重要属性, elem[0]存放要显示的内容
                                      //elem[1]存放链接, elem[2]存放title
    Cnode(int _type) : type(_type) {} //TODO:
} Cnode;                              //语法树的结点, 一个结点存放一行的信息

class Deriver
{
private:
    Cnode *Croot, *current;
    Tnode *Troot;
    string content, TOC;
    int cntTag = 0;          //为了让目录能够正确地索引到HTML中对应内容的位置而引入的记录
    char line[MAX_LINE_LEN]; //缓存要处理的行

    //判断是否为标题
    inline bool isHeading(Cnode *v)
    {
        return (v->type >= h1 && v->type <= h6);
    }
    //判断是否为图片
    inline bool isImage(Cnode *v)
    {
        return (v->type == image);
    }
    //判断是否为超链接
    inline bool isHref(Cnode *v)
    {
        return (v->type == href);
    }
    //递归销毁树的结点
    template <typename T>
    void destroy(T *v);

    //目录语法树的深度优先遍历
    void Tdfs(Tnode *v, string index);

    /*FIXME:
     *正文语法树的深度优先遍历
     *返回当前层的结点类型，比如del、strong、em等
     */
    int Cdfs(Cnode *v);
    /*判断是否是分割线
     *分割线的markdown语有以下三种模式
     * "***"或"---"
     * "* * *"或"- - -"
     * "*****"或"----------"
     * FIXME:注意！！！如果"***"后面跟了文本，这一行就不是分割线了！！！
     */
    inline bool isCutline(char *src);

    //生成段落
    inline void makePara(Cnode *v);

    /*行首的空格和tab不影响对markdown词法的解析
     *所以要先处理行首的空格和tab
     *src：要处理的一行字符串
     *返回: 由空格数和正文开始处的char*指针组成的pair类型
     */
    inline pair<int, char *> tabcount(char *src);

    /*判断当前行的类型
     *src: 所要判断的行
     *返回: 当前行的类型和除去行标志性关键字的正式内容的char*组成的pair类型
     */
    inline pair<int, char *> LineType(char *src);

    //给定树的深度depth, 寻找结点, 返回结点指针
    inline Cnode *findnode(int depth);

    /*新增结点的插入
     *结点的插入分两种类型
     *一种是向Tnode结构的树中插入目录结点
     *设置tag标签来标记一个目录结点所指向的正文结点, 
     *以实现点击目录项即可正确跳转到正文对应的位置
     */
    void Tinsert(Tnode *v, int x, const string &headstr, int tag);

    //向指定的结点v中插入要处理的串src
    //TODO:
    void Cinsert(Cnode *v, const string &src);

public:
    //构造函数
    Deriver(const std::string &filename);

    //获取markdown目录
    string getTable() { return TOC; }
    //获取markdown内容
    string getContent() { return content; }

    //析构函数
    ~Deriver()
    {
        destroy<Cnode>(Croot);
        destroy<Tnode>(Troot);
    }
};

//类函数定义
    template <typename T>
    void Deriver::destroy(T *v)
    {
        for (int i = 0; i < (int)v->vec.size(); i++)
        {
            destroy(v->vec[i]);
        }
        delete v;
    }

    void Deriver::Tdfs(Tnode *v, string index)
    {
        TOC += "<li>\n";
        TOC += "<a href=\"#" + v->tag + "\">" + index + " " + v->head + "</a>\n";
        int n = (int)v->vec.size();
        if (n)
        {
            TOC += "<ul>\n";
            for (int i = 0; i < n; i++)
            {
                Tdfs(v->vec[i], index + to_string(i + 1) + ".");
            }
            TOC += "</ul>\n";
        }
        TOC += "</li>\n";
    }

    int Deriver::Cdfs(Cnode *v)
    {
        if (v->type == paragraph && v->elem[0].empty() && v->vec.empty())
            return 0;

        content += frontTag[v->type];
        bool flag = true;

        //处理标题, 支持用目录进行跳转
        if (isHeading(v))
        {
            content += "id=\"" + v->elem[0] + "\">";
            flag = false;
        }

        //处理超链接
        if (isHref(v))
        {
            content += "<a href=\"" + v->elem[1] + "\" title=\"" + v->elem[2] + "\">" + v->elem[0] + "</a>";
            flag = false;
        }

        //处理图片
        if (isImage(v))
        {
            content += "<img alt=\"" + v->elem[0] + "\" src=\"" + v->elem[1] + "\" title=\"" + v->elem[2] + "\" />";
            flag = false;
        }

        //如果上面三者都不是, 则直接添加内容
        //FIXME:
        if (flag && v->type != 0)
        {
            content += v->elem[0];
            flag = false;
        }

        //递归遍历所有结点
        int vec_amount = (int)v->vec.size();
        int *ret = (int *)malloc(sizeof(int) * vec_amount);
        int record = 0;
        for (int i = 0; i < vec_amount; i++)
        {
            ret[i] = Cdfs(v->vec[i]);
            //TODO:输出该行前半部分的后置标签
            if (ret[i] == -1)
            {
                for (int j = i - 1; j >= 0; j--)
                    if (ret[j] > 0 && v->vec[j]->elem->size() == 0)
                        content += backTag[ret[j]];
                record = i + 1;
                content += v->vec[i]->elem[0];
            }
        }
        //拼接为结束标签
        //FIXME:
        if (!v->elem[0].empty())
        {
            content += backTag[v->type];
            //TODO:考虑“~~**混合1**~~、***混合2***”的情况
            if (v->type == 0) //如果该结点是nul型但elem[0]非空，说明结点后跟的是混合2的情况了，需要告知当前层要把前面的后置标签先输出
                return -1;
        }
        if (v->vec.size())
        {
            for (int i = vec_amount - 1; i >= record; i--)
                if (ret[i] > 0 && v->vec[i]->elem[0].size() == 0)
                    continue;
                    //content += backTag[ret[i]];
            content += backTag[v->type];
        }

        return v->type;
    }

    /*判断是否是分割线
     *分割线的markdown语有以下三种模式
     * "***"或"---"
     * "* * *"或"- - -"
     * "*****"或"----------"
     * FIXME:注意！！！如果"***"后面跟了文本，这一行就不是分割线了！！！
     */
    bool Deriver::isCutline(char *src)
    {
        int cnt = 0;
        char *ptr = src;
        //如果行首不是空格、tab、-或*, 则这一行不是分割线
        if (*ptr != ' ' && *ptr != '\t' && *ptr != '-' && *ptr != '*')
            return false;
        //模式一: 全部由'-'和空格/tab组成分割线
        while (*ptr)
        {
            if (*ptr != ' ' && *ptr != '\t' && *ptr != '-')
                break;
            if (*ptr == '-')
                cnt++;
            ptr++;
        }
        if (*ptr != '\n') //如果"___"后面跟了文本，这一行就不是分割线了
            return false;
        //模式二: 全部由'-'和空格/tab组成分割线
        if (cnt < 3)
        {
            cnt = 0;
            ptr = src;
            while (*ptr)
            {
                if (*ptr != ' ' && *ptr != '\t' && *ptr != '*')
                    break;
                if (*ptr == '*')
                    cnt++;
                ptr++;
            }
            if (*ptr != '\n') //如果"***"后面跟了文本，这一行就不是分割线了
                return false;
        }
        //如果出现三个以上的'-'或'*', 则需要增加一个分割线, 这时需要换行
        return (cnt >= 3);
    }

    void Deriver::makePara(Cnode *v)
    {
        if (v->vec.size() == 1u && v->vec.back()->type == paragraph)
            return;
        if (v->type == paragraph)
            return;
        if (v->type == nul)
        {
            v->type = paragraph;
            return;
        }
        Cnode *x = new Cnode(paragraph);
        x->vec = v->vec;
        v->vec.clear();
        v->vec.push_back(x);
    }

    /*行首的空格和tab不影响对markdown词法的解析
     *所以要先处理行首的空格和tab
     *src：要处理的一行字符串
     *返回: 由空格数和正文开始处的char*指针组成的pair类型
     */
    pair<int, char *> Deriver::tabcount(char *src)
    {
        //该行是空行
        if (strlen(src) == 0)
            return make_pair(0, nullptr);

        //从该行的第一个字符开始, 统计空格数和tab数, 遇到非空格且非tab时停止
        int spacecnt = 0, tabcnt = 0;
        for (int i = 0; src[i] != '\0'; i++)
        {
            if (src[i] == ' ')
                spacecnt++;
            else if (src[i] == '\t')
                tabcnt++;
            //如果内容前有空格和tab, 则统一按tab的个数处理, 一个tab = 4个空格
            else return make_pair(tabcnt + spacecnt / 4, src + i);
        }
        return make_pair(0, nullptr);
    }

    /*判断当前行的类型
     *src: 所要判断的行
     *返回: 当前行的类型和除去行标志性关键字的正式内容的char*组成的pair类型
     */
    pair<int, char *> Deriver::LineType(char *src)
    {
        char *ptr = src;

        //跳过`#`
        while (*ptr == '#')
            ptr++;
        //如果'#'紧跟空格, 则该行是标题
        if (ptr - src > 0 && *ptr == ' ')
            return make_pair(ptr - src + h1 - 1, ptr + 1); //返回标题级数

        //不是标题则从头分析
        ptr = src;

        //FIXME:需要判断是第一次还是第二次出现
        //如果出现```则说明是代码块
        if (strncmp(ptr, "```", 3) == 0)
            return make_pair(blockcode, ptr + 3);

        //FIXME:如果出现* + -, 并且它们的下一个字符为空格, 则该行是无序列表的一项
        if (strncmp(ptr, "- ", 2) == 0 || strncmp(ptr, "+ ", 2) == 0 || strncmp(ptr, "* ", 2) == 0)
            return make_pair(ul, ptr + 1);

        //如果出现 > 且下一个字符为空格, 则该行是引用
        if (strncmp(ptr, "> ", 2) == 0)
            return make_pair(quote, ptr + 1);

        //如果出现的是"数字. ", 则该行是有序列表的一项
        //FIXME:return是加1还是加2?
        char *ptr1 = ptr;
        while (*ptr1 && (isdigit(*ptr1)))
            ptr1++;
        if (ptr1 != ptr && strncmp(ptr1, ". ", 2) == 0)
            return make_pair(ol, ptr1 + 1);

        //否则就是普通段落
        return make_pair(paragraph, ptr);
    }

    //给定树的深度depth, 寻找结点, 返回结点指针
    Cnode * Deriver::findnode(int depth)
    {
        Cnode *ptr = Croot;
        while (!ptr->vec.empty() && depth != 0)
        {
            ptr = ptr->vec.back(); //返回尾元素的引用
            if (ptr->type == li)
                depth--;
        }
        return ptr;
    }

    /*新增结点的插入
     *结点的插入分两种类型
     *一种是向Tnode结构的树中插入目录结点
     *设置tag标签来标记一个目录结点所指向的正文结点, 
     *以实现点击目录项即可正确跳转到正文对应的位置
     */
    void Deriver::Tinsert(Tnode *v, int x, const string &headstr, int tag)
    {
        int n = v->vec.size(); //当前结点的vector项数
        if (x == 1)
        {
            v->vec.push_back(new Tnode(headstr)); //向量尾部增加一个结点
            v->vec.back()->tag = "tag" + to_string(tag);
            return;
        }
        if (!n || v->vec.back()->head.empty())
            v->vec.push_back(new Tnode(""));
        Tinsert(v->vec.back(), x - 1, headstr, tag);
    }

    void Deriver::Cinsert(Cnode *v, const string &src)
    {
        int srclen = src.size();
        bool incode = false,    //标志是否是行内代码
            inem = false,       //标志是否是行内斜体
            instrong = false,   //标志是否是行内加粗
            inautolink = false, //标志是否是行内链接
            indel = false,      //标志是否是删除线
            inunderline = false;//标志是否是下划线
        v->vec.push_back(new Cnode(nul));

        for (int i = 0; i < srclen; i++) //检查src字符串中的每一个字符
        {
            char ch = src[i];
            if (ch == '\\') //反斜杠的下一个字符即为转义字符
            {
                ch = src[++i];
                v->vec.back()->elem[0] += string(1, ch);
                continue;
            }

            //处理行内代码
            if (ch == '`' && !inautolink) //要求不是行内链接
            {
                if (incode)
                    v->vec.push_back(new Cnode(nul)); //如果incode为真，则当前ch是第二个'`'，增加一个空类型的结点
                else
                    v->vec.push_back(new Cnode(code)); //incode为假，当前ch是首个'`'，增加一个code类型的结点
                incode = !incode;
                continue;
            }

            //处理加粗，注意"***混合***”的情况
            if (ch == '*' && (i < srclen - 1 && (src[i + 1] == '*')) && !incode && !inautolink)
            { //读取到连续两个'*'，可能是加粗
                ++i;
                if (instrong)
                    v->vec.push_back(new Cnode(nul));
                else
                    v->vec.push_back(new Cnode(strong)); //如果instrong为假，则当前读到的连续两个'*'是首次，增加一个strong类型结点
                instrong = !instrong;
                continue;
            }
            if (ch == '_' && (i < srclen - 1 && (src[i + 1] == '_')) && !incode && !inautolink)
            { //读取到连续两个'_'，可能是加粗
                ++i;
                if (instrong)
                    v->vec.push_back(new Cnode(nul));
                else
                    v->vec.push_back(new Cnode(strong)); //如果instrong为假，则当前读到的连续两个'*'是首次，增加一个strong类型结点
                instrong = !instrong;
                continue;
            }

            //处理斜体
            //FIXME:
            //if (ch == '_' && !incode && !instrong && !inautolink)
            if (ch == '_' && src[i + 1] != '_' && !incode && !inautolink)
            { //只有单独的一个'_'，可能是斜体
                if (inem)
                    v->vec.push_back(new Cnode(nul));
                else
                    v->vec.push_back(new Cnode(em));
                inem = !inem;
                continue;
            }
            if (ch == '*' && src[i + 1] != '*' && !incode && !inautolink)
            { //只有单独的一个'*'，可能是斜体
                if (inem)
                    v->vec.push_back(new Cnode(nul));
                else
                    v->vec.push_back(new Cnode(em));
                inem = !inem;
                continue;
            }

            //处理删除线
            if (ch == '~' && (i < srclen - 1 && (src[i + 1] == '~')) && !incode && !inautolink)
            {
                ++i;
                //indel ? v->vec.push_back(new Cnode(nul)) : v->vec.push_back(new Cnode(del));
                if (indel)
                    v->vec.push_back(new Cnode(nul));
                else
                    v->vec.push_back(new Cnode(del));
                indel = !indel;
                continue;
            }

            //TODO:处理下划线
            if (ch == '<' && src[i + 1] == 'u' && src[i + 2] == '>' && !incode && !inautolink)
            {
                i = i + 2;
                if (inunderline)
                    v->vec.push_back(new Cnode(nul));
                else
                    v->vec.push_back(new Cnode(underline));
                inunderline = !inunderline;
                continue;
            }

            //处理图片
            if (ch == '!' && (i < srclen - 1 && src[i + 1] == '[') && !incode && !instrong && !inem && !inautolink)
            {
                v->vec.push_back(new Cnode(image));
                for (i += 2; i < srclen - 1 && src[i] != ']'; i++)
                    v->vec.back()->elem[0] += string(1, src[i]);
                i++;
                for (i++; i < srclen - 1 && src[i] != ' ' && src[i] != ')'; i++)
                    v->vec.back()->elem[1] += string(1, src[i]);
                if (src[i] != ')')
                    for (i++; i < srclen - 1 && src[i] != ')'; i++)
                        if (src[i] != '"')
                            v->vec.back()->elem[2] += string(1, src[i]);
                v->vec.push_back(new Cnode(nul));
                continue;
            }

            //处理超链接
            if (ch == '[' && !incode && !instrong && !inem && !inautolink)
            {
                v->vec.push_back(new Cnode(href));
                for (i++; i < srclen - 1 && src[i] != ']'; i++)
                    v->vec.back()->elem[0] += string(1, src[i]);
                i++;
                for (i++; i < srclen - 1 && src[i] != ' ' && src[i] != ')'; i++)
                    v->vec.back()->elem[1] += string(1, src[i]);
                if (src[i] != ')')
                    for (i++; i < srclen - 1 && src[i] != ')'; i++)
                        if (src[i] != '"')
                            v->vec.back()->elem[2] += string(1, src[i]);
                v->vec.push_back(new Cnode(nul));
                continue;
            }

            //ch读到的是普通文本
            v->vec.back()->elem[0] += string(1, ch);
            if (inautolink)
                v->vec.back()->elem[1] += string(1, ch);
        }
        if (src.size() >= 2)
            if (src.at(src.size() - 1) == ' ' && src.at(src.size() - 2) == ' ') //字符串最后连续两个空格
                v->vec.push_back(new Cnode(br));
    }

    Deriver::Deriver(const std::string &filename)
    {
        Troot = new Tnode("");
        Croot = new Cnode(nul);
        current = Croot;

        std::ifstream fin(filename);

        bool newpara = false;
        bool inblock = false;
        while (!fin.eof())
        {
            //从文件中获取一行
            fin.getline(line, MAX_LINE_LEN);
            //printf("start %s end\n", line);

            //处理不在代码块中且该行是分割线的情况
            if (!inblock && isCutline(line))
            {
                current = Croot;
                current->vec.push_back(new Cnode(hr));
                newpara = false;
                continue;
            }

            //计算一行中开始的空格和tab数
            std::pair<int, char *> ps = tabcount(line);

            //如果不是位于代码块中, 且ps.second为nulptr, 则直接读取下一行
            if (!inblock && ps.second == nullptr)
            {
                current = Croot;
                newpara = true;
                continue;
            }

            //分析该行文本的类型
            std::pair<int, char *> tp = LineType(ps.second);
            //printf("PSTART %s END\n", ps.second);

            //是代码块类型
            if (tp.first == blockcode)
            {
                //如果位于代码块中, 则push一个空类型的结点
                inblock ? current->vec.push_back(new Cnode(nul)) : current->vec.push_back(new Cnode(blockcode));
                inblock = !inblock;
                continue;
            }

            //如果位于代码块中, 直接将内容拼接到当前结点中
            if (inblock)
            {
                current->vec.back()->elem[0] += string(line) + '\n';
                continue;
            }

            //是普通段落
            //FIXME:删除线、粗体混用出错的地方
            if (tp.first == paragraph)
            {
                if (current == Croot)
                {
                    current = findnode(ps.first);
                    current->vec.push_back(new Cnode(paragraph));
                    current = current->vec.back();
                }
                bool flag = false;
                if (newpara && !current->vec.empty())
                {
                    Cnode *ptr = nullptr;
                    for (auto i : current->vec)
                    {
                        if (i->type == nul)
                            ptr = i;
                    }
                    if (ptr != nullptr)
                        makePara(ptr);
                    flag = true;
                }
                if (flag)
                {
                    current->vec.push_back(new Cnode(paragraph));
                    current = current->vec.back();
                }
                current->vec.push_back(new Cnode(nul));
                Cinsert(current->vec.back(), string(tp.second));
                //printf("duanluo%s \n", tp.second);
                newpara = false;
                continue;
            }

            current = findnode(ps.first);

            //如果是标题行, 则向其标签中插入属性tag
            if (tp.first >= h1 && tp.first <= h6)
            {
                current->vec.push_back(new Cnode(tp.first));
                current->vec.back()->elem[0] = "tag" + to_string(++cntTag);
                Cinsert(current->vec.back(), string(tp.second));
                Tinsert(Troot, tp.first - h1 + 1, string(tp.second), cntTag);
            }

            //如果是无序列表
            if (tp.first == ul)
            {
                if (current->vec.empty() || current->vec.back()->type != ul)
                {
                    current->vec.push_back(new Cnode(ul));
                }
                current = current->vec.back();
                current->vec.push_back(new Cnode(li));
                current = current->vec.back();
                Cinsert(current, string(tp.second));
            }
            //如果是有序列表
            if (tp.first == ol)
            {
                if (current->vec.empty() || current->vec.back()->type != ol)
                {
                    current->vec.push_back(new Cnode(ol));
                }
                current = current->vec.back();
                current->vec.push_back(new Cnode(li));
                current = current->vec.back();
                Cinsert(current, string(tp.second));
            }

            //如果是引用
            if (tp.first == quote)
            {
                if (current->vec.empty() || current->vec.back()->type != quote)
                {
                    current->vec.push_back(new Cnode(quote));
                }
                current = current->vec.back();
                if (newpara || current->vec.empty())
                    current->vec.push_back(new Cnode(paragraph));
                Cinsert(current->vec.back(), string(tp.second));
            }

            newpara = false;
        }

        //文件读取分析完毕
        fin.close();

        //深度优先遍历整棵语法树
        Cdfs(Croot);

        //构造目录
        TOC += "<ul>";
        for (int i = 0; i < (int)Troot->vec.size(); i++)
            Tdfs(Troot->vec[i], to_string(i + 1) + ".");
        TOC += "</ul>";
    }
#endif

```

### 3、文件结构

​	参见[用户使用说明-使用说明-文件内容](# 2 文件内容)。

## 六、团队分工

吴承泽：撰写软件报告，主要编写`Deriver`、`isCutline`、`Destroy`等函数；

刘伟：撰写概要设计报告，给出类的框架、结构体的定义等，主要编写`Cdfs`、`Tdfs`、`findnode`等函数；

梁峻滔：撰写需求分析报告，编写`Cinsert`、·`Tinsert`、`LineType`等函数。

编写好主要的函数后，三人共同调整各个函数的bug，吴承泽和刘伟主要负责调整多层次列表的处理，梁峻滔主要负责调整加粗、斜体、删除线、下划线等的混用处理。

## 七、实验感想

​		正如吴锋老师上课所说的那样，“写代码的学习效率远比看代码的效率高”，通过这次C++的大作业，我们深入了解了C++相对较C的特性以及熟悉了对各种库函数的使用，学习了C++中许多与C不同的用法。同时，通过这次大作业也更加熟悉了Markdown语言和html语言的语法特性。除此之外，通过此，对树型数据结构和深度遍历的各种方法也有了更深刻的认识。





### 